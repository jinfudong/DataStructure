'''
经典的应用场景：LRU缓存淘汰算法

缓存：
    CPU缓存：
        原理：CPU从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。
             而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，
             然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找不到就再从内存中取，这样就实现了内存访问速度更快的机制。
             也就是CPU缓存的意义：为了弥补内存访问速度过慢与CPU执行速度更快之间的差异。
             因为数组地址连续，链表不连续，所以数组访问比链表快.
    数据库缓存
    浏览器缓存

缓存满时的淘汰策略：
    1.先进先出策略FIFO（First In, First Out）
    2.最少使用策略LFU(Least Frequently Used)
    3.最近最少使用策略LRU（Least Recently Used）
        实现方法：1.维护一个有序单列表，越靠近链表尾部的节点是我们越早之前访问的，当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

链表和数组的区别：
    1.数组需要的空间是连续的，而链表需要的空间是不连续的，链表可以动态扩容（核心区别）
      数组如果需要再增加空间，则要重新申请一个更大的空间，把原来的数据放进去
    2.数组执行插入操作复杂度为O(n),随机查询访问操作复杂度为O(1)
      链表执行插入操作复杂度为O(1),随机查询访问操作复杂度为O(n)
'''